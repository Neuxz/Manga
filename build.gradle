// buildscript-dependencies
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.ajoberstar:grgit:1.4.0'
    }
}
ext {
    grgit = org.ajoberstar.grgit.Grgit.open()
    githead = grgit.head()
    gitbranch = grgit.branch.getCurrent()
}

// general setup
allprojects { project ->
	apply plugin: 'eclipse'
	
	group 'de.herrlock.manga'
	version '1.4.0-BETA-SNAPSHOT'
	
	apply plugin: 'java'
	apply plugin: 'findbugs'
	apply plugin: 'pmd'
	apply plugin: 'jacoco'
	apply plugin: 'maven-publish'
	apply plugin: 'project-report'
	apply plugin: 'build-dashboard'
	
	sourceCompatibility = '1.7'
	
	dependencies {
		testCompile 'junit:junit:4.12'
		testCompile 'org.mockito:mockito-core:1.10.19'
	}
	
	jar.manifest {
		attributes 'Built-With' : GradleVersion.current(),
			'Created-By' : "${System.properties.'java.runtime.version'} (${System.properties.'java.vm.vendor'})",
			'Info'
        attributes 'Branch' : gitbranch.getName(),
            'Date' : githead.getDate(),
            'Commit' : githead.id,
            'Git'
	}
	
	findbugs {
		effort = 'max'
		reportLevel = 'low'
	}
	tasks.withType(FindBugs) {
		reports {
			xml.enabled = false
			html.enabled = true
		}
	}
	
	pmd {
		ignoreFailures = true
		ruleSetFiles = files("${rootProject.projectDir}/misc/pmd.rulesets.xml")
	}
	
	eclipse.project {
		buildCommand 'edu.umd.cs.findbugs.plugin.eclipse.findbugsBuilder'
	}
	eclipse.classpath {
		file.withXml {
			def jfxrt = it.asNode().children().find{ entry ->
				return entry['@path'].contains('jfxrt') 
			}
			Node attributes = new Node(jfxrt, 'attributes')
			Node attribute = new Node(attributes, 'attribute')
			attribute.'@name' = 'javadoc_location'
			attribute.'@value' = 'http://docs.oracle.com/javafx/2/api/'
		}
	}
	
	task sourceJar(type: Jar) {
		from sourceSets.main.allJava
	}
	
	publishing {
		publications {
			mavenJava(MavenPublication) {
				from components.java
	
				artifact sourceJar {
					classifier 'sources'
				}
			}
		}
	}
	
	repositories {
		mavenCentral()
	}
}

// folder to store the content of the final zip-file
def temp = mkdir("${rootProject.buildDir}/disttemp/")

task createLibs (type: Copy, description: 'Create jar from subprojects and copies them and all project\'s dependencies into the lib-folder') {
	into new File(temp, 'lib')
	subprojects.each { s -> 
		dependsOn s.jar
		from s.jar
		from s.configurations.runtime
	}
    from rootProject.configurations.runtime
}

task copyDistAndMisc (type: Copy, description: 'Copy content of \"src/dist\" and other files to the temp-folder') {
	from 'src/dist'
	from 'LICENSE'
    // from ...
	into temp
}

task compileRun (description: 'Compile run.cs and copy the exe into the build-folder') {
	def csfolder = 'src/main/cs'
	def filename = 'Run.exe'
	def exefile = new File(csfolder, filename)
	doLast {
		try {
			exec {
				workingDir csfolder
                executable 'cmd'
                args '/c', 'csc', '/t:winexe', "/out:${filename}", '/nologo', 'run.cs'
			}
			copy {
				from exefile
				into temp
			}
			delete exefile
		} catch(org.gradle.process.internal.ExecException ex) {
			logger.warn 'run.cs could not be compiled to ${filename}, csc missing on path'
		}
	}
}

task copyLauncher(type: Copy, dependsOn: jar, description: 'Copies the launcher to the root folder') {
	from tasks.jar.outputs.files
	into temp
}

// distribution-task
task dist (type: Zip, group: 'build', dependsOn: [createLibs, copyDistAndMisc, compileRun, copyLauncher], description: 'Creates a distribution in a zip-file') {
	destinationDir = file('build')
	baseName = project.name
	version = project.version
	
	into baseName + '-' + version
	from temp
}


// project-configuration
dependencies {
	subprojects.each {
		compile it
	}
	compile 'commons-cli:commons-cli:1.3.1'
}

jar {
	archiveName = 'MangaLauncher.jar'
	manifest {
		attributes 'Main-Class' : 'de.herrlock.manga.Main',
			'Class-Path' : project.configurations.runtime
				.collect{ file -> "lib/${file.name}" }
				.sort{ it.toLowerCase() }
				.join(' ')
	}
}
